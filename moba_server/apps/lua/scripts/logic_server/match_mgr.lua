---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1.
--- DateTime: 2020/12/4 17:36
---房间管理，负责管理每一句游戏
---服务器启动一个定时器，每隔一段时间，来去等待列表里面去搜索可以进入的游戏房间
---讲玩家加入到房间的等待玩家数组里面去
---并把等待的玩家的信息，发送给其他客户端
---
local Stype = require("Stype")
local Cmd = require("Cmd")
local Respones = require("Respones")
local mysql_game = require("database/mysql_game")
local redis_game = require("database/redis_game")
local player = require("logic_server/player")
local Zone = require("logic_server/Zone")
local State = require("logic_server/State")

local match_mgr = {}
local sg_matchid = 1
local PLAYER_NUM = 2 --3v3
local LOGIC_FRAME_TIME = 50 --每帧间隔 66毫秒

function match_mgr:new(instant)
    if not instant then
        instant = {}
    end

    setmetatable(instant, { __index = self })
    return instant
end

function match_mgr:init(zid, game_start_callback)
    self.v_zid = zid
    self.v_matchid = sg_matchid
    self.v_member = 0
    sg_matchid = sg_matchid + 1

    self.v_state = State.InView
    self.v_frame_id = 1

    --观战列表
    self.v_inview_players = {}
    --左右两边列表
    self.v_lhs_players = {}
    self.v_rhs_players = {}

    self.v_all_match_FramesOpts = {} --保存的是游戏开始以来所有的帧操作
    self.v_next_FrameOpt = {} --当前的帧操作 对应协议 FrameOpts
    self.v_game_start_call_back = game_start_callback
end

function match_mgr:broadcast_cmd_inview_players(stype, ctype, body, not_to_player)
    for i, v in pairs(self.v_inview_players) do
        if v ~= not_to_player then
            v:send_cmd(stype, ctype, body)
        end
    end
end

function match_mgr:getmatchid()
    return self.v_matchid
end

--筛选玩家
function match_mgr:screenplayer(p)
    p:setmatchid(self.v_matchid)
    p:setzid(self.v_zid)

    for i = 1, PLAYER_NUM * 2 do
        if not self.v_inview_players[i] then
            self.v_inview_players[i] = p
            p:setseatid(i)
            p:side(0)
            if i > PLAYER_NUM then
                p:side(1)
            end
            break
        end
    end
end

function match_mgr:game_start()
    local players_match_info = {}
    for i = 1, PLAYER_NUM * 2 do
        local p = self.v_inview_players[i]
        if p then
            local info = {
                heroid = p:heroid(),
                seatid = p:getseatid(),
                side = p:side()
            }
            table.insert(players_match_info, info)

            if not p.v_is_robot then
                p:setmatchroom(self)
                if self.v_game_start_call_back then
                    self.v_game_start_call_back(self.v_zid, p)
                end
            end
        else
            Logger.error("error to find player")
        end
    end

    local body = {
        players_match_infos = players_match_info
    }
    self:broadcast_cmd_inview_players(Stype.Logic, Cmd.eGameStart, body)

    self.v_state = State.Playing
    self:update_players_state(State.Playing)

    --5秒以后  开始第一个帧事件  一秒钟交互20次，即 50毫秒发送一次数据
    self.v_frame_id = 1

    self.v_all_match_FramesOpts = {} --保存的是游戏开始以来所有的帧操作
    self.v_next_FrameOpt = { old_frameid = self.v_frame_id, opts = { { seatid = 1, opt_type = 1, x = 0, y = 0 } } } --当前的帧操作

    self.v_frame_timer = Scheduler.schedule(function()
        self:on_logic_frame()
    end, 2000, -1, LOGIC_FRAME_TIME)
end

--收到客户端发给服务器的下一帧的操作
function match_mgr:on_next_frame_event(next_frame_opts)
    --当前客户端已经同步了哪个
    local p = self.v_inview_players[next_frame_opts.seatid]
    if not p then
        Logger.error("player not find", next_frame_opts.seatid)
        return
    end

    --表示玩家客户端已同步
    if p.v_sunc_frameid < next_frame_opts.next_frameid - 1 then
        p.v_sunc_frameid = next_frame_opts.next_frameid - 1
    end

    if (next_frame_opts.next_frameid ~= self.v_frame_id) then
        return
    end

    if next_frame_opts.next_frameid ~= self.v_next_FrameOpt.old_frameid then
        Logger.error("error to", next_frame_opts.next_frameid)
    end

    if next_frame_opts.next_opts then
        for i = 1, #next_frame_opts.next_opts do
            table.insert(self.v_next_FrameOpt.opts, next_frame_opts.next_opts[i])
        end
    else
        Logger.error("error to find ", next_frame_opts.next_opts)
    end

end

function match_mgr:send_unsync_frames(p)
    local FrameOpts = {}

    local match_frames = self.v_all_match_FramesOpts
    local index = 0
    Logger.error(p.v_uinfo.unick, p.v_sunc_frameid, #match_frames)
    for i = (p.v_sunc_frameid + 1), #match_frames do
        index = index + 1
        table.insert(FrameOpts, match_frames[i])
        if index > 10 then
            break
        end
    end
    --table.insert(FrameOpts, match_frames[1])
    local body = {
        cur_frameid = self.v_frame_id, unsync_frames = FrameOpts
    }
    p:udp_send_cmd(Stype.Logic, Cmd.eLogicFrame, body)
end

function match_mgr:get_frame_msg_body()
    return {
        frameid = 0,
    }
end

--帧同步函数 定时发送
function match_mgr:on_logic_frame()
    table.insert(self.v_all_match_FramesOpts, self.v_next_FrameOpt)
    for i = 1, PLAYER_NUM * 2 do
        local p = self.v_inview_players[i]
        if p then
            self:send_unsync_frames(p)
        end
    end

    self.v_frame_id = self.v_frame_id + 1
    --self.v_next_FrameOpt = { old_frameid = self.v_frame_id, opts = {{seatid = 0, opt_type = 0, x = 0, y = 0}} }
    self.v_next_FrameOpt = { old_frameid = self.v_frame_id, opts = {} }
end

function match_mgr:update_players_state(state)
    for i = 1, PLAYER_NUM * 2 do
        self.v_inview_players[i].v_state = state
    end
end

--玩家重新返回战场 true 表示成功
function match_mgr:re_enter_match(p)
    if self.v_state ~= State.Playing then
        Logger.error("return")
        return false
    end

    self.v_member = self.v_member + 1
    if self.v_member > PLAYER_NUM * 2 then
        Logger.error("match room error!!!!!!!!!!!!!!!!!!!!!")
    end

    p.v_sunc_frameid = 0
    p:setmatchid(self.v_matchid)
    p:setzid(self.v_zid)
    Logger.error("seatid ", p:getseatid())

    --通知玩家已经进入房间
    local body = { zid = self.v_zid, matchid = self.v_matchid, seatid = p:getseatid(), side = p:side() }
    p:send_cmd(Stype.Logic, Cmd.eEnterMatch, body)

    print("re_enter_match id, member ", self.v_matchid, self.v_member, p.v_uinfo.unick)
    --玩家还要知道当前房间里面所有玩家的列表
    for i, v in pairs(self.v_inview_players) do
        if v ~= p then
            p:send_cmd(Stype.Logic, Cmd.eUserArrived, v:get_user_arrived())
        end
    end

    local players_match_info = {}
    if self.v_game_start_call_back then
        self.v_game_start_call_back(self.v_zid, p)
    end

    for i = 1, PLAYER_NUM * 2 do
        local p1 = self.v_inview_players[i]
        if p1 then
            local info = {
                heroid = p1:heroid(),
                seatid = p1:getseatid(),
                side = p1:side()
            }
            table.insert(players_match_info, info)
        elseif p:getseatid() == i then
            local info = {
                heroid = p:heroid(),
                seatid = p:getseatid(),
                side = p:side()
            }
            table.insert(players_match_info, info)
        else
            Logger.error("error to find player")
        end
    end

    local body = {
        players_match_infos = players_match_info
    }

    p:send_cmd(Stype.Logic, Cmd.eGameStart, body)
    print("cur match_room id, Cmd.eGameStart ", self.v_matchid, self.v_member, p.v_uinfo.unick)

    Scheduler.schedule(function()
        if p:getseatid() then
            self.v_inview_players[p:getseatid()] = p
        end
    end, 2000, 1)

    return true
end

function match_mgr:enter_player(p)
    if self.v_state ~= State.InView or p.v_state ~= State.InView then
        return false
    end
    self.v_member = self.v_member + 1
    p.v_sunc_frameid = 0
    --筛选玩家
    self:screenplayer(p)

    --发送命令，告诉客户端，你进入一个比赛，，zid，，matchid
    --end

    --通知玩家已经进入房间
    local body = { zid = self.v_zid, matchid = self.v_matchid, seatid = p:getseatid(), side = p:side() }
    p:send_cmd(Stype.Logic, Cmd.eEnterMatch, body)
    --end

    --广播消息
    self:broadcast_cmd_inview_players(Stype.Logic, Cmd.eUserArrived, p:get_user_arrived(), p)
    --end

    print("cur match_room id, member ", self.v_matchid, self.v_member, p.v_uinfo.unick)
    --玩家还要知道当前房间里面所有玩家的列表
    for i, v in pairs(self.v_inview_players) do
        if v ~= p then
            p:send_cmd(Stype.Logic, Cmd.eUserArrived, v:get_user_arrived())
        end
    end

    if self.v_member > PLAYER_NUM * 2 then
        Logger.error("match room error!!!!!!!!!!!!!!!!!!!!!")
    end

    if self.v_member == (PLAYER_NUM * 2) then
        --判断我们当前是否集结玩家结束了
        self.v_state = State.Ready
        self:update_players_state(State.Ready)
        --end

        --开始游戏
        --进入到一个选英雄的界面，知道所有玩家选好英雄这个状态
        --在游戏主页里面，自己设置你要用的英雄
        --或者服务器随机生成英雄的id
        for i = 1, PLAYER_NUM * 2 do
            if self.v_inview_players[i] then
                self.v_inview_players[i]:heroid(math.floor(math.random() * 5 + 1))
            end
        end
        self:game_start()
        --end
    end

    return true
end

function match_mgr:exit_player(p)
    self.v_member = self.v_member - 1
    local seatid = p:getseatid()
    self.v_inview_players[p:getseatid()] = nil
    if p:getstate() ~= State.Playing then
        p:clearmatchdata()
    end

    self:broadcast_cmd_inview_players(Stype.Logic, Cmd.eUserExitMatch, { seatid = seatid })
    p:send_cmd(Stype.Logic, Cmd.eExitMatchRes, { status = Respones.OK })
end

--玩家离线
function match_mgr:offline_player(p)
    if self.v_state == Stype.InView then
        self.v_member = self.v_member - 1
        local seatid = p:getseatid()
        self.v_inview_players[p:getseatid()] = nil
        if p:getstate() ~= State.Playing then
            p:clearmatchdata()
        end
        self:broadcast_cmd_inview_players(Stype.Logic, Cmd.eUserExitMatch, { seatid = seatid })
    end
end

return match_mgr