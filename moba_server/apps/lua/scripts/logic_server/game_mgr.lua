---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1.
--- DateTime: 2020/11/23 23:33
---游戏管理类
---

local mysql_game = require("database/mysql_game")
local mysql_center = require("database/mysql_auth_center")
local redis_game = require("database/redis_game")
local redis_center = require("database/redis_center")

local Stype = require("Stype")
local Cmd = require("Cmd")
local Respones = require("Respones")

local player = require("logic_server/player")
local robot_player = require("logic_server/robot_player")
local Zone = require("logic_server/Zone")
local match_mgr = require("logic_server/match_mgr")
local State = require("logic_server/State")

-- uid --->player
local logic_server_players = {}
local online_player_num = 0 --在线人数
local zone_wait_list = {} --等待列表
local zone_match_list = {} --当前开的比赛列表
zone_match_list[Zone.SGYD] = {}
zone_match_list[Zone.ASSY] = {}

local zone_robot_list = {} --机器人列表
zone_robot_list[Zone.SGYD] = {}
zone_robot_list[Zone.ASSY] = {}

local game_maching_list = {}  --当前正在比赛中的玩家
local is_logining_list = {} --正在请求登录

local function do_new_robot_players(robots)
    if #robots <= 0 then
        return
    end

    local half_len = math.floor(#robots * 0.5)

    for i = 1, half_len do
        local v = robots[i]
        local r_player = robot_player:new()
        r_player:init(v.uid, nil, nil)
        r_player:setzid(Zone.SGYD)

        zone_robot_list[Zone.SGYD][v.uid] = r_player
    end

    for i = half_len + 1, #robots do
        local v = robots[i]
        local r_player = robot_player:new()
        r_player:init(v.uid, nil, nil)
        r_player:setzid(Zone.ASSY)

        zone_robot_list[Zone.ASSY][v.uid] = r_player
    end
end

--加载机器人集合
local function do_load_robot_uinfo(now_index, robots)
    mysql_center.get_uinfo_by_uid(robots[now_index].uid, function(err, uinfo)
        if err or not uinfo then
            return
        end

        redis_center.set_uinfo_inredis(robots[now_index].uid, uinfo)
        now_index = now_index + 1
        if now_index > #robots then
            do_new_robot_players(robots)
            return
        end
        do_load_robot_uinfo(now_index, robots)
    end)
end

--加载数据库中所有的机器人的信息
local function do_load_robot_ugame_info()
    mysql_game.get_robots_ugame_info(function(err, ret)
        if err then
            return
        end
        if ret == nil or #ret <= 0 then
            return
        end

        for k, v in pairs(ret) do
            redis_game.set_ugame_info_inredis(v.uid, v)
        end
        do_load_robot_uinfo(1, ret)
    end)
end

local function load_robots()
    if not mysql_game.is_connected() or
            not mysql_center.is_connected() or
            not redis_game.is_connected() or
            not redis_center.is_connected() then
        Scheduler.once(load_robots, 5000)
        return
    end
    do_load_robot_ugame_info()
end

Scheduler.once(load_robots, 5000)

local function send_status(s, stype, ctype, uid, status)
    local msg = { stype, ctype, uid, {
        status = status
    } }
    Session.send_msg(s, msg)
end

local function on_game_start_callback(zid, p)
    if p.v_is_robot then
        return
    end
    game_maching_list[p:getuid()] = p
end

--搜索能够加入房间的房间号
local function search_inview_match_mgr(zid)
    local match_list = zone_match_list[zid]
    for k, v in ipairs(match_list) do
        if v.v_state == State.InView then
            return v
        end
    end

    local match = match_mgr:new()
    --table.insert(match_list, match)
    match:init(zid, on_game_start_callback)
    match_list[match:getmatchid()] = match

    return match
end

local function search_playing_match_mgr(zid, match_id)
    local match_list = zone_match_list[zid]
    for k, v in ipairs(match_list) do
        if v:getmatchid() == match_id then
            return v
        end
    end
end

--重新返回战场，如果返回失败，则登录成功
local function re_enter_match(p)
    Logger.error("re_enter_match>>>>>>>>>>>>>>>>>>>>>>>>>>>>>")
    local s = p:getsession()
    send_status(s, Stype.Logic, Cmd.eLoginLogicRes, p:getuid(), Respones.OK)
    if p:getzid() == -1 then
        return
    end

    local match = search_playing_match_mgr(p:getzid(), p:getmatchid())
    --房间不存在，比赛销毁
    if not match then
        return
    end

    if p.v_state ~= State.Playing then
        return
    end

    --重新返回战场
    if not match:re_enter_match(p) then
    end
end

local function login_logic_server(s, req)
    local uid = req[3]
    local stype = req[1]
    local body = req[4]

    print(body.ip, body.udp_port)

    if is_logining_list[uid] then
        return
    end
    is_logining_list[uid] = uid

    local p = logic_server_players[uid]
    local is_reconnect = game_maching_list[uid] ~= nil --在比赛途中退出后重新连接

    --玩家对象已经在队列中, 更新一下session就可以了
    Logger.error("p == nil", p == nil, online_player_num)
    if p then
        p:set_session(s)
        send_status(s, stype, Cmd.eLoginLogicRes, uid, Respones.OK)
    elseif is_reconnect then
        p = game_maching_list[uid]
        p:set_session(s)
        p:set_udp_addr(body.udp_ip, body.udp_port)
        p:is_login_out(false)
        p:get_info(uid, function(status)
            is_logining_list[uid] = nil
            Logger.error("call_back", status == Respones.OK)
            if status == Respones.OK then
                logic_server_players[uid] = p
                online_player_num = online_player_num + 1
                re_enter_match(p)
            else
                send_status(s, Stype.Logic, Cmd.eLoginLogicRes, uid, status)
            end
        end)
    else
        p = player:new()
        p:init(uid, s, function(status)
            is_logining_list[uid] = nil
            Logger.error("login_logic_server()", online_player_num, status)
            if status == Respones.OK then
                logic_server_players[uid] = p
                online_player_num = online_player_num + 1
            end
            send_status(s, Stype.Logic, Cmd.eLoginLogicRes, uid, status)
        end)
    end
    p:set_udp_addr(body.udp_ip, body.udp_port)
end

---加入等待列表
local function enter_zone(s, req)
    local stype = req[1]
    local uid = req[3]

    local p = logic_server_players[uid]

    if game_maching_list[uid] then
        Logger.error("game_maching_list return")
        return
    end

    if not p or p:getzid() ~= -1 then
        send_status(s, stype, Cmd.eEnterZoneRes, uid, Respones.InvalidOpt)
        return
    end

    local zid = req[4].zid;
    if zid ~= Zone.SGYD and zid ~= Zone.ASSY then
        send_status(s, stype, Cmd.eEnterZoneRes, uid, Respones.InvalidParams)
        return
    end

    if not zone_wait_list[zid] then
        zone_wait_list[zid] = {}
    end

    zone_wait_list[zid][uid] = p
    p:setzid(zid)
    send_status(s, stype, Cmd.eEnterZoneRes, uid, Respones.OK)
end

--定时检查匹配列表
local function do_match_players()
    for zid, wait_list in pairs(zone_wait_list) do
        for i, v in pairs(wait_list) do
            local match = search_inview_match_mgr(zid)
            if match then
                if not match:enter_player(v) then
                    Logger.error("match system error!!! : player state: ", v.v_state)
                else
                    wait_list[i] = nil
                end
            end
        end
    end
end

--启动一个定时器
Scheduler.schedule(do_match_players, 1000, -1, 5000)
--end

local function search_idle_robot(zid)
    local robots = zone_robot_list[zid]
    for i, v in pairs(robots) do
        if v:getmatchid() == -1 then
            return v
        end
    end
    return nil
end

--测试代码
local function do_exit_robot(match, robot)
    Scheduler.once(function()
        match:exit_player(robot)
    end, 5000)
end

local function do_push_robot_to_match()
    for zid, match_list in pairs(zone_match_list) do
        for k, match in pairs(match_list) do
            if match.v_state == State.InView then
                --找到一个空闲的match
                local robot = search_idle_robot(zid)
                if robot then
                    match:enter_player(robot)

                    --do_exit_robot(match, robot)
                end
            end
        end
    end
end

Scheduler.schedule(do_push_robot_to_match, 1000, -1, 1000)

--离开比赛房间
local function do_exit_match(s, req)
    local uid = req[3]
    local p = logic_server_players[uid]
    if not p then
        send_status(s, req[1], Cmd.eExitMatchRes, uid, Respones.InvalidOpt)
        return
    end

    --如果不是 inview 状态就无法离开
    if p:getstate() ~= State.InView or p:getmatchid() == -1 or p:getseatid() == -1 then
        send_status(s, req[1], Cmd.eExitMatchRes, uid, Respones.InvalidOpt)
        return
    end

    local match = zone_match_list[p:getzid()][p:getmatchid()]
    if not match or match.v_state ~= State.InView then
        send_status(s, req[1], Cmd.eExitMatchRes, uid, Respones.InvalidOpt)
        return
    end

    match:exit_player(p);
end

--掉线离开比赛房间
local function do_offline_match(req)
    local uid = req[3]
    local p = logic_server_players[uid]
    if not p then
        return
    end

    --如果不是 inview 状态就无法离开
    if p:getstate() ~= State.InView or p:getmatchid() == -1 or p:getseatid() == -1 then
        return
    end

    local match = zone_match_list[p:getzid()][p:getmatchid()]
    if not match or match.v_state ~= State.InView then
        return
    end

    match:offline_player(p)
end

--玩家离开了
local function on_player_disconnect(s, req)
    local uid = req[3]
    local p = logic_server_players[uid]
    if not p then
        return
    end

    p:set_session(nil)
    p:set_udp_addr(nil, 0)

    --游戏中的玩家我们后续考虑
    if p.v_zid ~= -1 then
        --玩家在等待列表里面，则移除
        if zone_wait_list[p.v_zid][uid] then
            zone_wait_list[p.v_zid][uid] = nil
            p.zid = -1
        end
    end
    --end

    --玩家断线离开中
    if p then
        Logger.error("on_player_disconnect", online_player_num)
        online_player_num = online_player_num - 1
        logic_server_players[uid] = nil
    end
    --end
    if p:getstate() == State.Playing then
        do_offline_match(p)
        p:is_login_out(true)
        local match = p:getmatchroom()
        if match then
            match:exit_player(p)
        end
    end

end

--网关断线
local function on_gateway_disconnect(s)
    for i, v in pairs(logic_server_players) do
        v:set_session(nil)
    end
end

--网关连接
local function on_gateway_connect(s)
    print("on_gateway_connect")
    for i, v in pairs(logic_server_players) do
        v:set_session(s)
    end
end

local function on_next_frame_event(s, req)
    --local stype = req[1]
    --local ctype = req[2]
    local body = req[4]

    local match = zone_match_list[body.zid][body.matchid]
    if not match or match.v_state ~= State.Playing then
        Logger.error("not find", match and match.v_state ~= State.Playing)
        return
    end
    match:on_next_frame_event(body)
end

local function do_udp_test(s, req)
    local stype = req[1]
    local ctype = req[2]
    local body = req[4]
    Logger.error(stype, ctype, body.content)
end

local game_mgr = {
    login_logic_server = login_logic_server,
    on_player_disconnect = on_player_disconnect,
    on_gateway_disconnect = on_gateway_disconnect,
    on_gateway_connect = on_gateway_connect,
    enter_zone = enter_zone,
    do_exit_match = do_exit_match,
    do_udp_test = do_udp_test,
    on_next_frame_event = on_next_frame_event,
}

return game_mgr