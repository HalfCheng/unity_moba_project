---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 1.
--- DateTime: 2020/9/20 14:51
---

local game_config = require("game_config")
local Respones = require("Respones")
local Stype = require("Stype")
local Cmd = require("Cmd")
local cfg_servers = game_config.servers

--通过 stype 获取 session 的映射
local server_session_man = {}
--当前正在做连接的服务器
local do_connecting = {}

-- 临时的ukey 来找 client session
local g_ukey = 1
local client_sessions_ukey = {}
--uid 来找 client session
local client_sessions_uid = {}

local function connect_to_server(stype, ip, port)
    Netbus.tcp_connect(ip, port, function(err, session)
        do_connecting[stype] = false
        if err ~= 0 then
            Logger.error(string.format("connect failed to server [%s] %s : %s", cfg_servers[stype].desic, ip, port))
            return
        end
        print(string.format("connect success to server [%s] %s : %s", cfg_servers[stype].desic, ip, port))
        server_session_man[stype] = session
    end)
end

--每隔一定事件检测一下，是否连接到服务器,如果没有连接，就连接服务器
local function chick_server_connect()
    for k, v in pairs(cfg_servers) do
        if server_session_man[v.stype] == nil and do_connecting[v.stype] == false then
            do_connecting[v.stype] = true
            print(string.format("connection to server [%s] %s : %s", v.desic, v.ip, v.port))
            connect_to_server(v.stype, v.ip, v.port)
        end
    end
end

local function gw_service_init()
    for k, v in pairs(cfg_servers) do
        server_session_man[v.stype] = nil
        do_connecting[v.stype] = false
    end
    chick_server_connect()

    --启动一个定时器
    Scheduler.schedule(chick_server_connect, 1000, -1, 1000)
    --end
end

local function is_login_return_cmd(ctype)
    if ctype == Cmd.eGuestLoginRes or ctype == Cmd.eUnameLoginRes then
        return true
    end
    return false
end

local function send_to_client(server_session, raw_cmd)
    local stype, ctype, utag = RawCmd.read_header(raw_cmd)
    local client_session

    --很有可能 uid来做 key， 可是同时要排除部署 ukey来做，，，，
    --必须要区分登陆前还是登陆后
    if is_login_return_cmd(ctype) then
        client_session = client_sessions_ukey[utag]
        client_sessions_ukey[utag] = nil

        if not client_session then
            Logger.error("send_to_client error!!!")
            return
        end

        local body = RawCmd.read_body(raw_cmd)
        if body.status ~= Respones.OK then
            RawCmd.set_utag(raw_cmd, 0)
            if client_session then
                Session.send_raw_cmd(client_session, raw_cmd)
            end
            return
        end
        local uid = body.uinfo.uid
        if client_sessions_uid[uid] and client_sessions_uid[uid] ~= client_session then
            local relogin_cmd = { Stype.Auth, Cmd.eRelogin, 0, nil }
            Session.send_msg(client_sessions_uid[uid], relogin_cmd)
            Session.close(client_sessions_uid[uid])
            client_sessions_uid[uid] = nil
        end

        client_sessions_uid[uid] = client_session
        Session.set_uid(client_session, uid)

        body.uinfo.uid = 0
        local login_res = { stype, ctype, 0, body }
        Session.send_msg(client_session, login_res)
        return
    end
    --end
    print(utag)
    client_session = client_sessions_uid[utag]
    if client_session then
        RawCmd.set_utag(raw_cmd, 0)
        Session.send_raw_cmd(client_session, raw_cmd)

        if ctype == Cmd.eLoginOutRes then
            Session.set_uid(client_session, 0)
            client_sessions_uid[utag] = nil
        end
    end
end

local function is_login_request_cmd(ctype)
    if ctype == Cmd.eGuestLoginReq or ctype == Cmd.eUnameLoginReq then
        return true
    end
    return false
end

local function send_to_server(client_session, raw_cmd)
    local stype, ctype, utag = RawCmd.read_header(raw_cmd)
    local ip, prot = Session.get_address(client_session)
    print("send_to_server", stype, ctype, utag, ip, prot)

    local server_session = server_session_man[stype]
    if server_session == nil then
        --系统错误
        Logger.error("error server_session!!!")
        return
    end

    if is_login_request_cmd(ctype) then
        --尚未登陆 需要服务器分配个临时 id
        utag = Session.get_utag(client_session)
        print("================utag", utag)
        if utag == 0 then
            utag = g_ukey
            g_ukey = g_ukey + 1
            Session.set_utag(client_session, utag)
        end
        client_sessions_ukey[utag] = client_session

    elseif ctype == Cmd.eLoginLogicReq then
        local uid = Session.get_uid(client_session)
        utag = uid
        if utag == 0 then
            --该操作需要先登录
            Logger.error("utag == 0")
            return
        end
        local tcp_ip, tcp_port = Session.get_address(client_session)
        local body = RawCmd.read_body(raw_cmd)
        body.udp_ip = tcp_ip
        print("login", body.udp_ip, body.udp_port)
        local login_logic_cmd = {stype, ctype, utag, body}
        Session.send_msg(server_session, login_logic_cmd)
    else
        local uid = Session.get_uid(client_session)
        utag = uid
        if utag == 0 then
            --该操作需要先登录
            Logger.error("utag == 0")
            return
        end
        -- client_sessions_uid[uid] = client_session
    end

    -- 打上 utag 后转发给服务器
    RawCmd.set_utag(raw_cmd, utag)
    Session.send_raw_cmd(server_session, raw_cmd)
end

--{stype, ctype, utag, body}
local function on_gw_recv_raw_cmd(s, raw_cmd)
    if Session.asclient(s) == 0 then
        send_to_server(s, raw_cmd)
    else
        --发送给客户端
        send_to_client(s, raw_cmd)
    end
end

local function on_gw_session_disconnect(s, stype)
    --连接到服务器的session断线了
    if Session.asclient(s) == 1 then
        for k, v in pairs(server_session_man) do
            if v == s then
                print(string.format("gateway disconnect: [%s]", cfg_servers[k].desic))
                server_session_man[k] = nil
                return
            end
        end
    end

    --连接到网关的客户端断线了
    --把客户端从临时映射表里删除
    local utag = Session.get_utag(s)
    if client_sessions_ukey[utag] ~= nil and client_sessions_ukey[utag] == s then
        client_sessions_ukey[utag] = nil
        Session.set_utag(s, 0)
    end
    --end

    --uid
    local uid = Session.get_uid(s)
    if client_sessions_uid[uid] ~= nil and client_sessions_uid[uid] == s then
        client_sessions_uid[uid] = nil
    end
    --end

    local server_session = server_session_man[stype]
    if not server_session then
        return
    end

    -- 当用户uid掉线后， 广播给其他客户端
    if uid ~= 0 then
        local user_lost = { stype, Cmd.eUserLostConn, uid, nil }
        Session.send_msg(server_session, user_lost)
    end
end

gw_service_init()

local gw_service = {
    on_session_recv_raw_cmd = on_gw_recv_raw_cmd,
    on_session_disconnect = on_gw_session_disconnect,
}

return gw_service